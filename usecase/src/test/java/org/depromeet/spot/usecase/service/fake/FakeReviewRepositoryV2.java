package org.depromeet.spot.usecase.service.fake;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicLong;

import org.depromeet.spot.common.exception.review.ReviewException.ReviewNotFoundException;
import org.depromeet.spot.domain.review.Review;
import org.depromeet.spot.domain.review.Review.ReviewType;
import org.depromeet.spot.domain.review.Review.SortCriteria;
import org.depromeet.spot.domain.review.ReviewCount;
import org.depromeet.spot.domain.review.ReviewYearMonth;
import org.depromeet.spot.usecase.port.in.review.ReadReviewUsecase.LocationInfo;
import org.depromeet.spot.usecase.port.out.review.ReviewRepository;

// FIXME: 구현 채워두기
public class FakeReviewRepositoryV2 implements ReviewRepository {

    private final AtomicLong autoGeneratedId = new AtomicLong(0);
    private final List<Review> reviewData = Collections.synchronizedList(new ArrayList<>());

    @Override
    public void updateLikesCount(Long reviewId, int likesCount) {
        reviewData.removeIf(item -> Objects.equals(item.getId(), reviewId));
        save(reviewId, likesCount);
    }

    private void save(long reviewId, int likesCount) {
        Review newReview = Review.builder().id(reviewId).likesCount(likesCount).build();
        reviewData.add(newReview);
    }

    @Override
    public void updateScrapsCount(Long reviewId, int likesCount) {}

    @Override
    public Review save(Review review) {
        if (review.getId() == null || review.getId() == 0) {
            Review newReview =
                    Review.builder().id(autoGeneratedId.incrementAndGet()).likesCount(0).build();
            reviewData.add(newReview);
            return newReview;
        } else {
            reviewData.removeIf(item -> Objects.equals(item.getId(), review.getId()));
            reviewData.add(review);
            return review;
        }
    }

    @Override
    public Review findById(Long id) {
        return getById(id).orElseThrow(ReviewNotFoundException::new);
    }

    private Optional<Review> getById(Long id) {
        return reviewData.stream().filter(review -> review.getId().equals(id)).findAny();
    }

    @Override
    public long countByUserId(Long userId) {
        return 0;
    }

    @Override
    public ReviewCount countAndSumLikesByUserId(Long id) {
        return null;
    }

    @Override
    public List<Review> findByStadiumIdAndBlockCode(
            Long stadiumId,
            String blockCode,
            Integer rowNumber,
            Integer seatNumber,
            Integer year,
            Integer month,
            String cursor,
            SortCriteria sortBy,
            Integer size) {
        return null;
    }

    @Override
    public List<Review> findAllByUserId(
            Long userId,
            Integer year,
            Integer month,
            String cursor,
            SortCriteria sortBy,
            Integer size,
            ReviewType reviewType) {
        return null;
    }

    @Override
    public List<ReviewYearMonth> findReviewMonthsByMemberId(Long memberId, ReviewType reviewType) {
        return null;
    }

    @Override
    public Long softDeleteByIdAndMemberId(Long reviewId, Long memberId) {
        return null;
    }

    @Override
    public LocationInfo findLocationInfoByStadiumIdAndBlockCode(Long stadiumId, String blockCode) {
        return null;
    }

    @Override
    public Review findLastReviewByMemberId(Long memberId) {
        return null;
    }

    @Override
    public long countByIdByMemberId(Long memberId) {
        return 0;
    }

    @Override
    public long countByStadiumIdAndBlockCode(
            Long stadiumId,
            String blockCode,
            Integer rowNumber,
            Integer seatNumber,
            Integer year,
            Integer month) {
        return 0;
    }
}
